
name: ScanCode copyrights/authors (source install, full parallel)

on:
  workflow_dispatch:
    inputs:
      components_file:
        description: "Path to input components JSON (default: input/components.json)"
        default: "input/nanos-0.1.54_19.json"
        required: true
        type: string
      # page_size removed (not needed when running everything concurrently)
      scan_options:
        description: "ScanCode options (space-separated)"
        default: "--copyright --info"
        required: true
        type: string

jobs:
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.build.outputs.matrix }}
      count: ${{ steps.count.outputs.count }}
      components_file: ${{ steps.echo.outputs.components_file }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Echo input path
        id: echo
        run: echo "components_file=${{ github.event.inputs.components_file }}" >> "$GITHUB_OUTPUT"

      - name: Validate & build dynamic matrix (wrap in {include:[...]})
        id: build
        shell: bash
        run: |
          set -e
          INPUT="${{ github.event.inputs.components_file }}"
          if [ ! -f "$INPUT" ]; then
            echo "::error::Input file not found: $INPUT"
            exit 1
          fi
          MATRIX=$(jq -c '{ include: [ .[] 
            | select(.Url != null and .Url != "") 
            | { Component: .Component, Url: .Url, version: .version, license: .license, SNo: (."S.No") } ] }' "$INPUT")
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"

      - name: Count components
        id: count
        run: |
          INPUT="${{ github.event.inputs.components_file }}"
          COUNT=$(jq 'length' "$INPUT")
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"

      - name: Debug matrix
        run: |
          echo '${{ steps.build.outputs.matrix }}' | jq .

  build-scancode:
    runs-on: ubuntu-latest
    needs: prepare-matrix
    outputs:
      scancode_path: ${{ steps.paths.outputs.scancode_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python (3.11)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
        # ScanCode supports Python 3.9â€“3.13. [3](blob:https://m365.cloud.microsoft/595628d9-a8c8-4019-a693-327216579b68)[4](blob:https://m365.cloud.microsoft/68941719-015b-4cd9-b92b-3c4176910543)

      - name: Clone ScanCode Toolkit (git)
        run: |
          git clone --depth=1 https://github.com/aboutcode-org/scancode-toolkit.git
          cd scancode-toolkit
          git fetch --tags
          git checkout v32.2.1
        # Project repo & releases refs. [5](blob:https://m365.cloud.microsoft/f17acca1-bb94-45b9-ac50-5539812c1130)[6](blob:https://m365.cloud.microsoft/327b8b89-159c-4e89-8b9f-db9155df617e)

      - name: Configure & install (source install)
        run: |
          cd scancode-toolkit
          ./configure --with-defaults
        # Source install via configure script. [3](blob:https://m365.cloud.microsoft/595628d9-a8c8-4019-a693-327216579b68)

      - name: Resolve scancode binary path
        id: paths
        shell: bash
        run: |
          echo "scancode_path=$PWD/scancode-toolkit/scancode" >> "$GITHUB_OUTPUT"

  scan-component:
    runs-on: ubuntu-latest
    needs: [prepare-matrix, build-scancode]
    strategy:
      fail-fast: false
      # NO max-parallel -> run all matrix jobs at once (subject to runner limits). [1](https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/run-job-variations)
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Clone target repository
        if: ${{ matrix.Url != '' }}
        shell: bash
        run: |
          set -e
          git clone --depth=1 "${{ matrix.Url }}" repo || {
            echo "::warning::Clone failed for ${{ matrix.Url }}"; 
            mkdir -p repo; 
          }

      - name: Run ScanCode (source install, direct CLI)
        shell: bash
        run: |
          set -e
          mkdir -p out
          SCANCODE="${{ needs.build-scancode.outputs.scancode_path }}"
          "$SCANCODE" ${{ github.event.inputs.scan_options }} \
            --json-pp scan_output.json repo || true

          python - <<'PY'
          import json, os
          comp = {
            "Component": os.environ.get("COMPONENT"),
            "version": os.environ.get("VERSION"),
            "Url": os.environ.get("URL"),
            "license": os.environ.get("LICENSE"),
            "S.No": int(os.environ.get("SNO", "0")),
          }
          copyrights, authors = set(), set()
          p = "scan_output.json"
          if os.path.exists(p):
            with open(p, "r", encoding="utf-8") as f:
              data = json.load(f)
            for fi in data.get("files", []):
              for c in fi.get("copyrights", []):
                val = (c.get("value") or c.get("copyright") or "").strip()
                if val: copyrights.add(val)
              for a in fi.get("authors", []):
                val = (a.get("value") or a.get("author") or "").strip()
                if val: authors.add(val)
          comp["copyrights"] = sorted(copyrights)
          comp["authors"] = sorted(authors)
          os.makedirs("out", exist_ok=True)
          out_file = f'out/component-{comp["S.No"]}.json'
          with open(out_file, "w", encoding="utf-8") as f:
            json.dump(comp, f, indent=2)
          PY
        env:
          COMPONENT: ${{ matrix.Component }}
          VERSION:   ${{ matrix.version }}
          URL:       ${{ matrix.Url }}
          LICENSE:   ${{ matrix.license }}
          SNO:       ${{ matrix.SNo }}

      - name: Upload per-component artifact (v4, immediate)
        uses: actions/upload-artifact@v4
        with:
          name: component-${{ matrix.SNo }}-${{ matrix.Component }}
          path: out
        # Artifacts v4 are immediately available per job. [2](https://stackoverflow.com/questions/78999879/how-do-i-upload-artifacts-with-the-github-api-or-cli)

  aggregate:
    runs-on: ubuntu-latest
    needs: scan-component
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all component artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: component-*
          merge-multiple: true
        # v4 pattern + merge-multiple for aggregation. [2](https://stackoverflow.com/questions/78999879/how-do-i-upload-artifacts-with-the-github-api-or-cli)

      - name: Merge back into original list (dynamic input path)
        id: merge
        shell: bash
        run: |
          set -e
          INPUT="${{ needs.prepare-matrix.outputs.components_file }}"
          python - <<'PY'
          import json, glob, os
          inp = os.environ["INPUT"]
          with open(inp, "r", encoding="utf-8") as f:
            components = json.load(f)
          enriched = {}
          for path in glob.glob("**/component-*.json", recursive=True):
            with open(path, "r", encoding="utf-8") as f:
              obj = json.load(f)
              enriched[obj["S.No"]] = obj
          out = []
          for item in components:
            sno = item.get("S.No")
            add = enriched.get(sno, {})
            merged = dict(item)
            merged["copyrights"] = add.get("copyrights", [])
            merged["authors"]    = add.get("authors", [])
            out.append(merged)
          base, ext = os.path.splitext(inp)
          final_name = f"{base}-with-copyrights-{len(out)}{ext or '.json'}"
          with open(final_name, "w", encoding="utf-8") as f:
            json.dump(out, f, indent=2)
          print(final_name)
          PY
        env:
          INPUT: ${{ needs.prepare-matrix.outputs.components_file }}

      - name: Upload aggregated JSON
        uses: actions/upload-artifact@v4
        with:
          name: components-with-copyrights
          path: ${{ steps.merge.outputs }}
